local a={}local b={}b.OpMode={iABC=0,iABx=1,iAsBx=2}b.SIZE_C=9;b.SIZE_B=9;b.SIZE_Bx=b.SIZE_C+b.SIZE_B;b.SIZE_A=8;b.SIZE_OP=6;b.POS_OP=0;b.POS_A=b.POS_OP+b.SIZE_OP;b.POS_C=b.POS_A+b.SIZE_A;b.POS_B=b.POS_C+b.SIZE_C;b.POS_Bx=b.POS_C;b.MAXARG_Bx=math.ldexp(1,b.SIZE_Bx)-1;b.MAXARG_sBx=math.floor(b.MAXARG_Bx/2)b.MAXARG_A=math.ldexp(1,b.SIZE_A)-1;b.MAXARG_B=math.ldexp(1,b.SIZE_B)-1;b.MAXARG_C=math.ldexp(1,b.SIZE_C)-1;function b:GET_OPCODE(c)return self.ROpCode[c.OP]end;function b:SET_OPCODE(c,d)c.OP=self.OpCode[d]end;function b:GETARG_A(c)return c.A end;function b:SETARG_A(c,e)c.A=e end;function b:GETARG_B(c)return c.B end;function b:SETARG_B(c,f)c.B=f end;function b:GETARG_C(c)return c.C end;function b:SETARG_C(c,f)c.C=f end;function b:GETARG_Bx(c)return c.Bx end;function b:SETARG_Bx(c,f)c.Bx=f end;function b:GETARG_sBx(c)return c.Bx-self.MAXARG_sBx end;function b:SETARG_sBx(c,f)c.Bx=f+self.MAXARG_sBx end;function b:CREATE_ABC(d,g,f,h)return{OP=self.OpCode[d],A=g,B=f,C=h}end;function b:CREATE_ABx(d,g,i)return{OP=self.OpCode[d],A=g,Bx=i}end;function b:CREATE_Inst(h)local d=h%64;h=(h-d)/64;local g=h%256;h=(h-g)/256;return self:CREATE_ABx(d,g,h)end;function b:Instruction(c)if c.Bx then c.C=c.Bx%512;c.B=(c.Bx-c.C)/512 end;local j=c.A*64+c.OP;local k=j%256;j=c.C*64+(j-k)/256;local l=j%256;j=c.B*128+(j-l)/256;local m=j%256;local n=(j-m)/256;return string.char(k,l,m,n)end;function b:DecodeInst(o)local p=string.byte;local c={}local j=p(o,1)local q=j%64;c.OP=q;j=p(o,2)*4+(j-q)/64;local g=j%256;c.A=g;j=p(o,3)*4+(j-g)/256;local h=j%512;c.C=h;c.B=p(o,4)*2+(j-h)/512;local r=self.OpMode[tonumber(string.sub(self.opmodes[q+1],7,7))]if r~="iABC"then c.Bx=c.B*512+c.C end;return c end;b.BITRK=math.ldexp(1,b.SIZE_B-1)function b:ISK(o)return o>=self.BITRK end;function b:INDEXK(o)return o-self.BITRK end;b.MAXINDEXRK=b.BITRK-1;function b:RKASK(o)return o+self.BITRK end;b.NO_REG=b.MAXARG_A;b.opnames={}b.OpCode={}b.ROpCode={}local c=0;for s in string.gmatch([[
MOVE LOADK LOADBOOL LOADNIL GETUPVAL
GETGLOBAL GETTABLE SETGLOBAL SETUPVAL SETTABLE
NEWTABLE SELF ADD SUB MUL
DIV MOD POW UNM NOT
LEN CONCAT JMP EQ LT
LE TEST TESTSET CALL TAILCALL
RETURN FORLOOP FORPREP TFORLOOP SETLIST
CLOSE CLOSURE VARARG
]],"%S+")do local t="OP_"..s;b.opnames[c]=s;b.OpCode[t]=c;b.ROpCode[c]=t;c=c+1 end;b.NUM_OPCODES=c;b.OpArgMask={OpArgN=0,OpArgU=1,OpArgR=2,OpArgK=3}function b:getOpMode(u)return self.opmodes[self.OpCode[u]]%4 end;function b:getBMode(u)return math.floor(self.opmodes[self.OpCode[u]]/16)%4 end;function b:getCMode(u)return math.floor(self.opmodes[self.OpCode[u]]/4)%4 end;function b:testAMode(u)return math.floor(self.opmodes[self.OpCode[u]]/64)%2 end;function b:testTMode(u)return math.floor(self.opmodes[self.OpCode[u]]/128)end;b.LFIELDS_PER_FLUSH=50;local function r(v,g,f,h,u)local b=b;return v*128+g*64+b.OpArgMask[f]*16+b.OpArgMask[h]*4+b.OpMode[u]end;b.opmodes={r(0,1,"OpArgK","OpArgN","iABx"),r(0,1,"OpArgU","OpArgU","iABC"),r(0,1,"OpArgR","OpArgN","iABC"),r(0,1,"OpArgU","OpArgN","iABC"),r(0,1,"OpArgK","OpArgN","iABx"),r(0,1,"OpArgR","OpArgK","iABC"),r(0,0,"OpArgK","OpArgN","iABx"),r(0,0,"OpArgU","OpArgN","iABC"),r(0,0,"OpArgK","OpArgK","iABC"),r(0,1,"OpArgU","OpArgU","iABC"),r(0,1,"OpArgR","OpArgK","iABC"),r(0,1,"OpArgK","OpArgK","iABC"),r(0,1,"OpArgK","OpArgK","iABC"),r(0,1,"OpArgK","OpArgK","iABC"),r(0,1,"OpArgK","OpArgK","iABC"),r(0,1,"OpArgK","OpArgK","iABC"),r(0,1,"OpArgK","OpArgK","iABC"),r(0,1,"OpArgR","OpArgN","iABC"),r(0,1,"OpArgR","OpArgN","iABC"),r(0,1,"OpArgR","OpArgN","iABC"),r(0,1,"OpArgR","OpArgR","iABC"),r(0,0,"OpArgR","OpArgN","iAsBx"),r(1,0,"OpArgK","OpArgK","iABC"),r(1,0,"OpArgK","OpArgK","iABC"),r(1,0,"OpArgK","OpArgK","iABC"),r(1,1,"OpArgR","OpArgU","iABC"),r(1,1,"OpArgR","OpArgU","iABC"),r(0,1,"OpArgU","OpArgU","iABC"),r(0,1,"OpArgU","OpArgU","iABC"),r(0,0,"OpArgU","OpArgN","iABC"),r(0,1,"OpArgR","OpArgN","iAsBx"),r(0,1,"OpArgR","OpArgN","iAsBx"),r(1,0,"OpArgN","OpArgU","iABC"),r(0,0,"OpArgU","OpArgU","iABC"),r(0,0,"OpArgN","OpArgN","iABC"),r(0,1,"OpArgU","OpArgN","iABx"),r(0,1,"OpArgU","OpArgN","iABC")}b.opmodes[0]=r(0,1,"OpArgR","OpArgN","iABC")a.LuaP=b;local w={}function w:make_getS(x)local f=x;return function()if not f then return nil end;local y=f;f=nil;return y end end;function w:init(z,y,A)if not z then return end;local B={}B.reader=z;B.data=y or""B.name=A;if not y or y==""then B.n=0 else B.n=#y end;B.p=0;return B end;function w:fill(B)local x=B.reader()B.data=x;if not x or x==""then return"EOZ"end;B.n,B.p=#x-1,1;return string.sub(x,1,1)end;function w:zgetc(B)local t,C=B.n,B.p+1;if t>0 then B.n,B.p=t-1,C;return string.sub(B.data,C,C)else return self:fill(B)end end;a.LuaZ=w;local D={}local b=a.LuaP;D.LUA_SIGNATURE="\27Lua"D.LUA_TNUMBER=3;D.LUA_TSTRING=4;D.LUA_TNIL=0;D.LUA_TBOOLEAN=1;D.LUA_TNONE=-1;D.LUAC_VERSION=0x51;D.LUAC_FORMAT=0;D.LUAC_HEADERSIZE=12;function D:make_setS()local x={}x.data=""local E=function(F,x)if not F then return 0 end;x.data=x.data..F;return 0 end;return E,x end;function D:ttype(d)local G=type(d.value)if G=="number"then return self.LUA_TNUMBER elseif G=="string"then return self.LUA_TSTRING elseif G=="nil"then return self.LUA_TNIL elseif G=="boolean"then return self.LUA_TBOOLEAN else return self.LUA_TNONE end end;function D:from_double(o)local function H(s)local h=s%256;return(s-h)/256,string.char(h)end;local I=0;if o<0 then I=1;o=-o end;local J,K=math.frexp(o)if o==0 then J,K=0,0 elseif o==1/0 then J,K=0,2047 else J=(J*2-1)*math.ldexp(0.5,53)K=K+1022 end;local s,p=""o=math.floor(J)for c=1,6 do o,p=H(o)s=s..p end;o,p=H(K*16+o)s=s..p;o,p=H(I*128+o)s=s..p;return s end;function D:from_int(o)local s=""o=math.floor(o)if o<0 then o=4294967296+o end;for c=1,4 do local h=o%256;s=s..string.char(h)o=math.floor(o/256)end;return s end;function D:DumpBlock(f,L)if L.status==0 then L.status=L.write(f,L.data)end end;function D:DumpChar(M,L)self:DumpBlock(string.char(M),L)end;function D:DumpInt(o,L)self:DumpBlock(self:from_int(o),L)end;function D:DumpNumber(o,L)self:DumpBlock(self:from_double(o),L)end;function D:DumpString(F,L)if F==nil then self:DumpInt(0,L)else F=F.."\0"self:DumpInt(#F,L)self:DumpBlock(F,L)end end;function D:DumpCode(N,L)local t=N.sizecode;self:DumpInt(t,L)for c=0,t-1 do self:DumpBlock(b:Instruction(N.code[c]),L)end end;function D:DumpConstants(N,L)local t=N.sizek;self:DumpInt(t,L)for c=0,t-1 do local d=N.k[c]local G=self:ttype(d)self:DumpChar(G,L)if G==self.LUA_TNIL then elseif G==self.LUA_TBOOLEAN then self:DumpChar(d.value and 1 or 0,L)elseif G==self.LUA_TNUMBER then self:DumpNumber(d.value,L)elseif G==self.LUA_TSTRING then self:DumpString(d.value,L)else end end;t=N.sizep;self:DumpInt(t,L)for c=0,t-1 do self:DumpFunction(N.p[c],N.source,L)end end;function D:DumpDebug(N,L)local t;t=L.strip and 0 or N.sizelineinfo;self:DumpInt(t,L)for c=0,t-1 do self:DumpInt(N.lineinfo[c],L)end;t=L.strip and 0 or N.sizelocvars;self:DumpInt(t,L)for c=0,t-1 do self:DumpString(N.locvars[c].varname,L)self:DumpInt(N.locvars[c].startpc,L)self:DumpInt(N.locvars[c].endpc,L)end;t=L.strip and 0 or N.sizeupvalues;self:DumpInt(t,L)for c=0,t-1 do self:DumpString(N.upvalues[c],L)end end;function D:DumpFunction(N,C,L)local O=N.source;if O==C or L.strip then O=nil end;self:DumpString(O,L)self:DumpInt(N.lineDefined,L)self:DumpInt(N.lastlinedefined,L)self:DumpChar(N.nups,L)self:DumpChar(N.numparams,L)self:DumpChar(N.is_vararg,L)self:DumpChar(N.maxstacksize,L)self:DumpCode(N,L)self:DumpConstants(N,L)self:DumpDebug(N,L)end;function D:DumpHeader(L)local P=self:header()assert(#P==self.LUAC_HEADERSIZE)self:DumpBlock(P,L)end;function D:header()local o=1;return self.LUA_SIGNATURE..string.char(self.LUAC_VERSION,self.LUAC_FORMAT,o,4,4,4,8,0)end;function D:dump(Q,N,R,y,S)local L={}L.L=Q;L.write=R;L.data=y;L.strip=S;L.status=0;self:DumpHeader(L)self:DumpFunction(N,nil,L)L.write(nil,L.data)return L.status end;a.LuaU=D;local w=a.LuaZ;local T={}T.RESERVED=[[
TK_AND and
TK_BREAK break
TK_DO do
TK_ELSE else
TK_ELSEIF elseif
TK_END end
TK_FALSE false
TK_FOR for
TK_FUNCTION function
TK_IF if
TK_IN in
TK_LOCAL local
TK_NIL nil
TK_NOT not
TK_OR or
TK_REPEAT repeat
TK_RETURN return
TK_THEN then
TK_TRUE true
TK_UNTIL until
TK_WHILE while
TK_CONCAT ..
TK_DOTS ...
TK_EQ ==
TK_GE >=
TK_LE <=
TK_NE ~=
TK_NAME <name>
TK_NUMBER <number>
TK_STRING <string>
TK_EOS <eof>]]T.MAXSRC=80;T.MAX_INT=2147483645;T.LUA_QS="'%s'"T.LUA_COMPAT_LSTR=1;function T:init()local U,V={},{}for s in string.gmatch(self.RESERVED,"[^\n]+")do local W,W,X,Y=string.find(s,"(%S+)%s+(%S+)")U[X]=Y;V[Y]=X end;self.tokens=U;self.enums=V end;function T:chunkid(O,Z)local _;local a0=string.sub(O,1,1)if a0=="="then _=string.sub(O,2,Z)else if a0=="@"then O=string.sub(O,2)Z=Z-#" '...' "local a1=#O;_=""if a1>Z then O=string.sub(O,1+a1-Z)_=_.."..."end;_=_..O else local a2=string.find(O,"[\n\r]")a2=a2 and a2-1 or#O;Z=Z-#" [string \"...\"] "if a2>Z then a2=Z end;_="[string \""if a2<#O then _=_..string.sub(O,1,a2).."..."else _=_..O end;_=_.."\"]"end end;return _ end;function T:token2str(a3,a4)if string.sub(a4,1,3)~="TK_"then if string.find(a4,"%c")then return string.format("char(%d)",string.byte(a4))end;return a4 else end;return self.tokens[a4]end;function T:lexerror(a3,a5,a4)local function a6(a3,a4)if a4=="TK_NAME"or a4=="TK_STRING"or a4=="TK_NUMBER"then return a3.buff else return self:token2str(a3,a4)end end;local x=self:chunkid(a3.source,self.MAXSRC)local a5=string.format("%s:%d: %s",x,a3.linenumber,a5)if a4 then a5=string.format("%s near "..self.LUA_QS,a5,a6(a3,a4))end;error(a5)end;function T:syntaxerror(a3,a5)self:lexerror(a3,a5,a3.t.token)end;function T:currIsNewline(a3)return a3.current=="\n"or a3.current=="\r"end;function T:inclinenumber(a3)local a7=a3.current;self:nextc(a3)if self:currIsNewline(a3)and a3.current~=a7 then self:nextc(a3)end;a3.linenumber=a3.linenumber+1;if a3.linenumber>=self.MAX_INT then self:syntaxerror(a3,"chunk has too many lines")end end;function T:setinput(Q,a3,B,O)if not a3 then a3={}end;if not a3.lookahead then a3.lookahead={}end;if not a3.t then a3.t={}end;a3.decpoint="."a3.L=Q;a3.lookahead.token="TK_EOS"a3.z=B;a3.fs=nil;a3.linenumber=1;a3.lastline=1;a3.source=O;self:nextc(a3)end;function T:check_next(a3,a8)if not string.find(a8,a3.current,1,1)then return false end;self:save_and_next(a3)return true end;function T:next(a3)a3.lastline=a3.linenumber;if a3.lookahead.token~="TK_EOS"then a3.t.seminfo=a3.lookahead.seminfo;a3.t.token=a3.lookahead.token;a3.lookahead.token="TK_EOS"else a3.t.token=self:llex(a3,a3.t)end end;function T:lookahead(a3)a3.lookahead.token=self:llex(a3,a3.lookahead)end;function T:nextc(a3)local h=w:zgetc(a3.z)a3.current=h;return h end;function T:save(a3,h)local x=a3.buff;a3.buff=x..h end;function T:save_and_next(a3)self:save(a3,a3.current)return self:nextc(a3)end;function T:str2d(F)local a9=tonumber(F)if a9 then return a9 end;if string.lower(string.sub(F,1,2))=="0x"then a9=tonumber(F,16)if a9 then return a9 end end;return nil end;function T:buffreplace(a3,aa,ab)local a9,x="",a3.buff;for C=1,#x do local h=string.sub(x,C,C)if h==aa then h=ab end;a9=a9 ..h end;a3.buff=a9 end;function T:trydecpoint(a3,ac)local a7=a3.decpoint;self:buffreplace(a3,a7,a3.decpoint)local ad=self:str2d(a3.buff)ac.seminfo=ad;if not ad then self:buffreplace(a3,a3.decpoint,".")self:lexerror(a3,"malformed number","TK_NUMBER")end end;function T:read_numeral(a3,ac)repeat self:save_and_next(a3)until string.find(a3.current,"%D")and a3.current~="."if self:check_next(a3,"Ee")then self:check_next(a3,"+-")end;while string.find(a3.current,"^%w$")or a3.current=="_"do self:save_and_next(a3)end;self:buffreplace(a3,".",a3.decpoint)local ad=self:str2d(a3.buff)ac.seminfo=ad;if not ad then self:trydecpoint(a3,ac)end end;function T:skip_sep(a3)local ae=0;local F=a3.current;self:save_and_next(a3)while a3.current=="="do self:save_and_next(a3)ae=ae+1 end;return a3.current==F and ae or-ae-1 end;function T:read_long_string(a3,ac,af)local ag=0;self:save_and_next(a3)if self:currIsNewline(a3)then self:inclinenumber(a3)end;while true do local h=a3.current;if h=="EOZ"then self:lexerror(a3,ac and"unfinished long string"or"unfinished long comment","TK_EOS")elseif h=="["then if self.LUA_COMPAT_LSTR then if self:skip_sep(a3)==af then self:save_and_next(a3)ag=ag+1;if self.LUA_COMPAT_LSTR==1 then if af==0 then self:lexerror(a3,"nesting of [[...]] is deprecated","[")end end end end elseif h=="]"then if self:skip_sep(a3)==af then self:save_and_next(a3)if self.LUA_COMPAT_LSTR and self.LUA_COMPAT_LSTR==2 then ag=ag-1;if af==0 and ag>=0 then break end end;break end elseif self:currIsNewline(a3)then self:save(a3,"\n")self:inclinenumber(a3)if not ac then a3.buff=""end else if ac then self:save_and_next(a3)else self:nextc(a3)end end end;if ac then local C=3+af;ac.seminfo=string.sub(a3.buff,C,-C)end end;function T:read_string(a3,ah,ac)self:save_and_next(a3)while a3.current~=ah do local h=a3.current;if h=="EOZ"then self:lexerror(a3,"unfinished string","TK_EOS")elseif self:currIsNewline(a3)then self:lexerror(a3,"unfinished string","TK_STRING")elseif h=="\\"then h=self:nextc(a3)if self:currIsNewline(a3)then self:save(a3,"\n")self:inclinenumber(a3)elseif h~="EOZ"then local c=string.find("abfnrtv",h,1,1)if c then self:save(a3,string.sub("\a\b\f\n\r\t\v",c,c))self:nextc(a3)elseif not string.find(h,"%d")then self:save_and_next(a3)else h,c=0,0;repeat h=10*h+a3.current;self:nextc(a3)c=c+1 until c>=3 or not string.find(a3.current,"%d")if h>255 then self:lexerror(a3,"escape sequence too large","TK_STRING")end;self:save(a3,string.char(h))end end else self:save_and_next(a3)end end;self:save_and_next(a3)ac.seminfo=string.sub(a3.buff,2,-2)end;function T:llex(a3,ac)a3.buff=""while true do local h=a3.current;if self:currIsNewline(a3)then self:inclinenumber(a3)elseif h=="-"then h=self:nextc(a3)if h~="-"then return"-"end;local af=-1;if self:nextc(a3)=='['then af=self:skip_sep(a3)a3.buff=""end;if af>=0 then self:read_long_string(a3,nil,af)a3.buff=""else while not self:currIsNewline(a3)and a3.current~="EOZ"do self:nextc(a3)end end elseif h=="["then local af=self:skip_sep(a3)if af>=0 then self:read_long_string(a3,ac,af)return"TK_STRING"elseif af==-1 then return"["else self:lexerror(a3,"invalid long string delimiter","TK_STRING")end elseif h=="="then h=self:nextc(a3)if h~="="then return"="else self:nextc(a3)return"TK_EQ"end elseif h=="<"then h=self:nextc(a3)if h~="="then return"<"else self:nextc(a3)return"TK_LE"end elseif h==">"then h=self:nextc(a3)if h~="="then return">"else self:nextc(a3)return"TK_GE"end elseif h=="~"then h=self:nextc(a3)if h~="="then return"~"else self:nextc(a3)return"TK_NE"end elseif h=="\""or h=="'"then self:read_string(a3,h,ac)return"TK_STRING"elseif h=="."then h=self:save_and_next(a3)if self:check_next(a3,".")then if self:check_next(a3,".")then return"TK_DOTS"else return"TK_CONCAT"end elseif not string.find(h,"%d")then return"."else self:read_numeral(a3,ac)return"TK_NUMBER"end elseif h=="EOZ"then return"TK_EOS"else if string.find(h,"%s")then self:nextc(a3)elseif string.find(h,"%d")then self:read_numeral(a3,ac)return"TK_NUMBER"elseif string.find(h,"[_%a]")then repeat h=self:save_and_next(a3)until h=="EOZ"or not string.find(h,"[_%w]")local ai=a3.buff;local X=self.enums[ai]if X then return X end;ac.seminfo=ai;return"TK_NAME"else self:nextc(a3)return h end end end end;a.LuaX=T;local aj={}local b=a.LuaP;local T=a.LuaX;aj.MAXSTACK=250;function aj:ttisnumber(d)if d then return type(d.value)=="number"else return false end end;function aj:nvalue(d)return d.value end;function aj:setnilvalue(d)d.value=nil end;function aj:setsvalue(d,o)d.value=o end;aj.setnvalue=aj.setsvalue;aj.sethvalue=aj.setsvalue;aj.setbvalue=aj.setsvalue;function aj:numadd(g,f)return g+f end;function aj:numsub(g,f)return g-f end;function aj:nummul(g,f)return g*f end;function aj:numdiv(g,f)return g/f end;function aj:nummod(g,f)return g%f end;function aj:numpow(g,f)return g^f end;function aj:numunm(g)return-g end;function aj:numisnan(g)return not g==g end;aj.NO_JUMP=-1;aj.BinOpr={OPR_ADD=0,OPR_SUB=1,OPR_MUL=2,OPR_DIV=3,OPR_MOD=4,OPR_POW=5,OPR_CONCAT=6,OPR_NE=7,OPR_EQ=8,OPR_LT=9,OPR_LE=10,OPR_GT=11,OPR_GE=12,OPR_AND=13,OPR_OR=14,OPR_NOBINOPR=15}aj.UnOpr={OPR_MINUS=0,OPR_NOT=1,OPR_LEN=2,OPR_NOUNOPR=3}function aj:getcode(ak,al)return ak.f.code[al.info]end;function aj:codeAsBx(ak,d,am,an)return self:codeABx(ak,d,am,an+b.MAXARG_sBx)end;function aj:setmultret(ak,al)self:setreturns(ak,al,luaY.LUA_MULTRET)end;function aj:hasjumps(al)return al.t~=al.f end;function aj:isnumeral(al)return al.k=="VKNUM"and al.t==self.NO_JUMP and al.f==self.NO_JUMP end;function aj:_nil(ak,aa,t)if ak.pc>ak.lasttarget then if ak.pc==0 then if aa>=ak.nactvar then return end else local ao=ak.f.code[ak.pc-1]if b:GET_OPCODE(ao)=="OP_LOADNIL"then local ap=b:GETARG_A(ao)local aq=b:GETARG_B(ao)if ap<=aa and aa<=aq+1 then if aa+t-1>aq then b:SETARG_B(ao,aa+t-1)end;return end end end end;self:codeABC(ak,"OP_LOADNIL",aa,aa+t-1,0)end;function aj:jump(ak)local ar=ak.jpc;ak.jpc=self.NO_JUMP;local as=self:codeAsBx(ak,"OP_JMP",0,self.NO_JUMP)as=self:concat(ak,as,ar)return as end;function aj:ret(ak,a0,at)self:codeABC(ak,"OP_RETURN",a0,at+1,0)end;function aj:condjump(ak,q,am,au,av)self:codeABC(ak,q,am,au,av)return self:jump(ak)end;function aj:fixjump(ak,aw,ax)local ay=ak.f.code[aw]local az=ax-(aw+1)assert(ax~=self.NO_JUMP)if math.abs(az)>b.MAXARG_sBx then T:syntaxerror(ak.ls,"control structure too long")end;b:SETARG_sBx(ay,az)end;function aj:getlabel(ak)ak.lasttarget=ak.pc;return ak.pc end;function aj:getjump(ak,aw)local az=b:GETARG_sBx(ak.f.code[aw])if az==self.NO_JUMP then return self.NO_JUMP else return aw+1+az end end;function aj:getjumpcontrol(ak,aw)local aA=ak.f.code[aw]local aB=ak.f.code[aw-1]if aw>=1 and b:testTMode(b:GET_OPCODE(aB))~=0 then return aB else return aA end end;function aj:need_value(ak,aC)while aC~=self.NO_JUMP do local c=self:getjumpcontrol(ak,aC)if b:GET_OPCODE(c)~="OP_TESTSET"then return true end;aC=self:getjump(ak,aC)end;return false end;function aj:patchtestreg(ak,aD,aE)local c=self:getjumpcontrol(ak,aD)if b:GET_OPCODE(c)~="OP_TESTSET"then return false end;if aE~=b.NO_REG and aE~=b:GETARG_B(c)then b:SETARG_A(c,aE)else b:SET_OPCODE(c,"OP_TEST")local f=b:GETARG_B(c)b:SETARG_A(c,f)b:SETARG_B(c,0)end;return true end;function aj:removevalues(ak,aC)while aC~=self.NO_JUMP do self:patchtestreg(ak,aC,b.NO_REG)aC=self:getjump(ak,aC)end end;function aj:patchlistaux(ak,aC,aF,aE,aG)while aC~=self.NO_JUMP do local aH=self:getjump(ak,aC)if self:patchtestreg(ak,aC,aE)then self:fixjump(ak,aC,aF)else self:fixjump(ak,aC,aG)end;aC=aH end end;function aj:dischargejpc(ak)self:patchlistaux(ak,ak.jpc,ak.pc,b.NO_REG,ak.pc)ak.jpc=self.NO_JUMP end;function aj:patchlist(ak,aC,aI)if aI==ak.pc then self:patchtohere(ak,aC)else assert(aI<ak.pc)self:patchlistaux(ak,aC,aI,b.NO_REG,aI)end end;function aj:patchtohere(ak,aC)self:getlabel(ak)ak.jpc=self:concat(ak,ak.jpc,aC)end;function aj:concat(ak,aJ,aK)if aK==self.NO_JUMP then return aJ elseif aJ==self.NO_JUMP then return aK else local aC=aJ;local aH=self:getjump(ak,aC)while aH~=self.NO_JUMP do aC=aH;aH=self:getjump(ak,aC)end;self:fixjump(ak,aC,aK)end;return aJ end;function aj:checkstack(ak,t)local aL=ak.freereg+t;if aL>ak.f.maxstacksize then if aL>=self.MAXSTACK then T:syntaxerror(ak.ls,"function or expression too complex")end;ak.f.maxstacksize=aL end end;function aj:reserveregs(ak,t)self:checkstack(ak,t)ak.freereg=ak.freereg+t end;function aj:freereg(ak,aE)if not b:ISK(aE)and aE>=ak.nactvar then ak.freereg=ak.freereg-1;assert(aE==ak.freereg)end end;function aj:freeexp(ak,al)if al.k=="VNONRELOC"then self:freereg(ak,al.info)end end;function aj:addk(ak,aM,s)local Q=ak.L;local aN=ak.h[aM.value]local N=ak.f;if self:ttisnumber(aN)then return self:nvalue(aN)else aN={}self:setnvalue(aN,ak.nk)ak.h[aM.value]=aN;luaY:growvector(Q,N.k,ak.nk,N.sizek,nil,b.MAXARG_Bx,"constant table overflow")N.k[ak.nk]=s;local aO=ak.nk;ak.nk=ak.nk+1;return aO end end;function aj:stringK(ak,F)local d={}self:setsvalue(d,F)return self:addk(ak,d,d)end;function aj:numberK(ak,aP)local d={}self:setnvalue(d,aP)return self:addk(ak,d,d)end;function aj:boolK(ak,f)local d={}self:setbvalue(d,f)return self:addk(ak,d,d)end;function aj:nilK(ak)local aM,s={},{}self:setnilvalue(s)self:sethvalue(aM,ak.h)return self:addk(ak,aM,s)end;function aj:setreturns(ak,al,aQ)if al.k=="VCALL"then b:SETARG_C(self:getcode(ak,al),aQ+1)elseif al.k=="VVARARG"then b:SETARG_B(self:getcode(ak,al),aQ+1)b:SETARG_A(self:getcode(ak,al),ak.freereg)aj:reserveregs(ak,1)end end;function aj:setoneret(ak,al)if al.k=="VCALL"then al.k="VNONRELOC"al.info=b:GETARG_A(self:getcode(ak,al))elseif al.k=="VVARARG"then b:SETARG_B(self:getcode(ak,al),2)al.k="VRELOCABLE"end end;function aj:dischargevars(ak,al)local aM=al.k;if aM=="VLOCAL"then al.k="VNONRELOC"elseif aM=="VUPVAL"then al.info=self:codeABC(ak,"OP_GETUPVAL",0,al.info,0)al.k="VRELOCABLE"elseif aM=="VGLOBAL"then al.info=self:codeABx(ak,"OP_GETGLOBAL",0,al.info)al.k="VRELOCABLE"elseif aM=="VINDEXED"then self:freereg(ak,al.aux)self:freereg(ak,al.info)al.info=self:codeABC(ak,"OP_GETTABLE",0,al.info,al.aux)al.k="VRELOCABLE"elseif aM=="VVARARG"or aM=="VCALL"then self:setoneret(ak,al)else end end;function aj:code_label(ak,am,f,aR)self:getlabel(ak)return self:codeABC(ak,"OP_LOADBOOL",am,f,aR)end;function aj:discharge2reg(ak,al,aE)self:dischargevars(ak,al)local aM=al.k;if aM=="VNIL"then self:_nil(ak,aE,1)elseif aM=="VFALSE"or aM=="VTRUE"then self:codeABC(ak,"OP_LOADBOOL",aE,al.k=="VTRUE"and 1 or 0,0)elseif aM=="VK"then self:codeABx(ak,"OP_LOADK",aE,al.info)elseif aM=="VKNUM"then self:codeABx(ak,"OP_LOADK",aE,self:numberK(ak,al.nval))elseif aM=="VRELOCABLE"then local aw=self:getcode(ak,al)b:SETARG_A(aw,aE)elseif aM=="VNONRELOC"then if aE~=al.info then self:codeABC(ak,"OP_MOVE",aE,al.info,0)end else assert(al.k=="VVOID"or al.k=="VJMP")return end;al.info=aE;al.k="VNONRELOC"end;function aj:discharge2anyreg(ak,al)if al.k~="VNONRELOC"then self:reserveregs(ak,1)self:discharge2reg(ak,al,ak.freereg-1)end end;function aj:exp2reg(ak,al,aE)self:discharge2reg(ak,al,aE)if al.k=="VJMP"then al.t=self:concat(ak,al.t,al.info)end;if self:hasjumps(al)then local aS;local aT=self.NO_JUMP;local aU=self.NO_JUMP;if self:need_value(ak,al.t)or self:need_value(ak,al.f)then local aV=al.k=="VJMP"and self.NO_JUMP or self:jump(ak)aT=self:code_label(ak,aE,0,1)aU=self:code_label(ak,aE,1,0)self:patchtohere(ak,aV)end;aS=self:getlabel(ak)self:patchlistaux(ak,al.f,aS,aE,aT)self:patchlistaux(ak,al.t,aS,aE,aU)end;al.f,al.t=self.NO_JUMP,self.NO_JUMP;al.info=aE;al.k="VNONRELOC"end;function aj:exp2nextreg(ak,al)self:dischargevars(ak,al)self:freeexp(ak,al)self:reserveregs(ak,1)self:exp2reg(ak,al,ak.freereg-1)end;function aj:exp2anyreg(ak,al)self:dischargevars(ak,al)if al.k=="VNONRELOC"then if not self:hasjumps(al)then return al.info end;if al.info>=ak.nactvar then self:exp2reg(ak,al,al.info)return al.info end end;self:exp2nextreg(ak,al)return al.info end;function aj:exp2val(ak,al)if self:hasjumps(al)then self:exp2anyreg(ak,al)else self:dischargevars(ak,al)end end;function aj:exp2RK(ak,al)self:exp2val(ak,al)local aM=al.k;if aM=="VKNUM"or aM=="VTRUE"or aM=="VFALSE"or aM=="VNIL"then if ak.nk<=b.MAXINDEXRK then if al.k=="VNIL"then al.info=self:nilK(ak)else al.info=al.k=="VKNUM"and self:numberK(ak,al.nval)or self:boolK(ak,al.k=="VTRUE")end;al.k="VK"return b:RKASK(al.info)end elseif aM=="VK"then if al.info<=b.MAXINDEXRK then return b:RKASK(al.info)end else end;return self:exp2anyreg(ak,al)end;function aj:storevar(ak,aW,aX)local aM=aW.k;if aM=="VLOCAL"then self:freeexp(ak,aX)self:exp2reg(ak,aX,aW.info)return elseif aM=="VUPVAL"then local al=self:exp2anyreg(ak,aX)self:codeABC(ak,"OP_SETUPVAL",al,aW.info,0)elseif aM=="VGLOBAL"then local al=self:exp2anyreg(ak,aX)self:codeABx(ak,"OP_SETGLOBAL",al,aW.info)elseif aM=="VINDEXED"then local al=self:exp2RK(ak,aX)self:codeABC(ak,"OP_SETTABLE",aW.info,aW.aux,al)else assert(0)end;self:freeexp(ak,aX)end;function aj:_self(ak,al,aY)self:exp2anyreg(ak,al)self:freeexp(ak,al)local aZ=ak.freereg;self:reserveregs(ak,2)self:codeABC(ak,"OP_SELF",aZ,al.info,self:exp2RK(ak,aY))self:freeexp(ak,aY)al.info=aZ;al.k="VNONRELOC"end;function aj:invertjump(ak,al)local aw=self:getjumpcontrol(ak,al.info)assert(b:testTMode(b:GET_OPCODE(aw))~=0 and b:GET_OPCODE(aw)~="OP_TESTSET"and b:GET_OPCODE(aw)~="OP_TEST")b:SETARG_A(aw,b:GETARG_A(aw)==0 and 1 or 0)end;function aj:jumponcond(ak,al,a_)if al.k=="VRELOCABLE"then local b0=self:getcode(ak,al)if b:GET_OPCODE(b0)=="OP_NOT"then ak.pc=ak.pc-1;return self:condjump(ak,"OP_TEST",b:GETARG_B(b0),0,a_ and 0 or 1)end end;self:discharge2anyreg(ak,al)self:freeexp(ak,al)return self:condjump(ak,"OP_TESTSET",b.NO_REG,al.info,a_ and 1 or 0)end;function aj:goiftrue(ak,al)local aw;self:dischargevars(ak,al)local aM=al.k;if aM=="VK"or aM=="VKNUM"or aM=="VTRUE"then aw=self.NO_JUMP elseif aM=="VFALSE"then aw=self:jump(ak)elseif aM=="VJMP"then self:invertjump(ak,al)aw=al.info else aw=self:jumponcond(ak,al,false)end;al.f=self:concat(ak,al.f,aw)self:patchtohere(ak,al.t)al.t=self.NO_JUMP end;function aj:goiffalse(ak,al)local aw;self:dischargevars(ak,al)local aM=al.k;if aM=="VNIL"or aM=="VFALSE"then aw=self.NO_JUMP elseif aM=="VTRUE"then aw=self:jump(ak)elseif aM=="VJMP"then aw=al.info else aw=self:jumponcond(ak,al,true)end;al.t=self:concat(ak,al.t,aw)self:patchtohere(ak,al.f)al.f=self.NO_JUMP end;function aj:codenot(ak,al)self:dischargevars(ak,al)local aM=al.k;if aM=="VNIL"or aM=="VFALSE"then al.k="VTRUE"elseif aM=="VK"or aM=="VKNUM"or aM=="VTRUE"then al.k="VFALSE"elseif aM=="VJMP"then self:invertjump(ak,al)elseif aM=="VRELOCABLE"or aM=="VNONRELOC"then self:discharge2anyreg(ak,al)self:freeexp(ak,al)al.info=self:codeABC(ak,"OP_NOT",0,al.info,0)al.k="VRELOCABLE"else assert(0)end;al.f,al.t=al.t,al.f;self:removevalues(ak,al.f)self:removevalues(ak,al.t)end;function aj:indexed(ak,v,aM)v.aux=self:exp2RK(ak,aM)v.k="VINDEXED"end;function aj:constfolding(q,b1,b2)local aP;if not self:isnumeral(b1)or not self:isnumeral(b2)then return false end;local b3=b1.nval;local b4=b2.nval;if q=="OP_ADD"then aP=self:numadd(b3,b4)elseif q=="OP_SUB"then aP=self:numsub(b3,b4)elseif q=="OP_MUL"then aP=self:nummul(b3,b4)elseif q=="OP_DIV"then if b4==0 then return false end;aP=self:numdiv(b3,b4)elseif q=="OP_MOD"then if b4==0 then return false end;aP=self:nummod(b3,b4)elseif q=="OP_POW"then aP=self:numpow(b3,b4)elseif q=="OP_UNM"then aP=self:numunm(b3)elseif q=="OP_LEN"then return false else assert(0)aP=0 end;if self:numisnan(aP)then return false end;b1.nval=aP;return true end;function aj:codearith(ak,q,b1,b2)if self:constfolding(q,b1,b2)then return else local b5=q~="OP_UNM"and q~="OP_LEN"and self:exp2RK(ak,b2)or 0;local b6=self:exp2RK(ak,b1)if b6>b5 then self:freeexp(ak,b1)self:freeexp(ak,b2)else self:freeexp(ak,b2)self:freeexp(ak,b1)end;b1.info=self:codeABC(ak,q,0,b6,b5)b1.k="VRELOCABLE"end end;function aj:codecomp(ak,q,a_,b1,b2)local b6=self:exp2RK(ak,b1)local b5=self:exp2RK(ak,b2)self:freeexp(ak,b2)self:freeexp(ak,b1)if a_==0 and q~="OP_EQ"then b6,b5=b5,b6;a_=1 end;b1.info=self:condjump(ak,q,a_,b6,b5)b1.k="VJMP"end;function aj:prefix(ak,q,al)local b2={}b2.t,b2.f=self.NO_JUMP,self.NO_JUMP;b2.k="VKNUM"b2.nval=0;if q=="OPR_MINUS"then if not self:isnumeral(al)then self:exp2anyreg(ak,al)end;self:codearith(ak,"OP_UNM",al,b2)elseif q=="OPR_NOT"then self:codenot(ak,al)elseif q=="OPR_LEN"then self:exp2anyreg(ak,al)self:codearith(ak,"OP_LEN",al,b2)else assert(0)end end;function aj:infix(ak,q,s)if q=="OPR_AND"then self:goiftrue(ak,s)elseif q=="OPR_OR"then self:goiffalse(ak,s)elseif q=="OPR_CONCAT"then self:exp2nextreg(ak,s)elseif q=="OPR_ADD"or q=="OPR_SUB"or q=="OPR_MUL"or q=="OPR_DIV"or q=="OPR_MOD"or q=="OPR_POW"then if not self:isnumeral(s)then self:exp2RK(ak,s)end else self:exp2RK(ak,s)end end;aj.arith_op={OPR_ADD="OP_ADD",OPR_SUB="OP_SUB",OPR_MUL="OP_MUL",OPR_DIV="OP_DIV",OPR_MOD="OP_MOD",OPR_POW="OP_POW"}aj.comp_op={OPR_EQ="OP_EQ",OPR_NE="OP_EQ",OPR_LT="OP_LT",OPR_LE="OP_LE",OPR_GT="OP_LT",OPR_GE="OP_LE"}aj.comp_cond={OPR_EQ=1,OPR_NE=0,OPR_LT=1,OPR_LE=1,OPR_GT=0,OPR_GE=0}function aj:posfix(ak,q,b1,b2)local function b7(b1,b2)b1.k=b2.k;b1.info=b2.info;b1.aux=b2.aux;b1.nval=b2.nval;b1.t=b2.t;b1.f=b2.f end;if q=="OPR_AND"then assert(b1.t==self.NO_JUMP)self:dischargevars(ak,b2)b2.f=self:concat(ak,b2.f,b1.f)b7(b1,b2)elseif q=="OPR_OR"then assert(b1.f==self.NO_JUMP)self:dischargevars(ak,b2)b2.t=self:concat(ak,b2.t,b1.t)b7(b1,b2)elseif q=="OPR_CONCAT"then self:exp2val(ak,b2)if b2.k=="VRELOCABLE"and b:GET_OPCODE(self:getcode(ak,b2))=="OP_CONCAT"then assert(b1.info==b:GETARG_B(self:getcode(ak,b2))-1)self:freeexp(ak,b1)b:SETARG_B(self:getcode(ak,b2),b1.info)b1.k="VRELOCABLE"b1.info=b2.info else self:exp2nextreg(ak,b2)self:codearith(ak,"OP_CONCAT",b1,b2)end else local b8=self.arith_op[q]if b8 then self:codearith(ak,b8,b1,b2)else local b9=self.comp_op[q]if b9 then self:codecomp(ak,b9,self.comp_cond[q],b1,b2)else assert(0)end end end end;function aj:fixline(ak,ba)ak.f.lineinfo[ak.pc-1]=ba end;function aj:code(ak,c,ba)local N=ak.f;self:dischargejpc(ak)luaY:growvector(ak.L,N.code,ak.pc,N.sizecode,nil,luaY.MAX_INT,"code size overflow")N.code[ak.pc]=c;luaY:growvector(ak.L,N.lineinfo,ak.pc,N.sizelineinfo,nil,luaY.MAX_INT,"code size overflow")N.lineinfo[ak.pc]=ba;local aw=ak.pc;ak.pc=ak.pc+1;return aw end;function aj:codeABC(ak,d,g,f,h)assert(b:getOpMode(d)==b.OpMode.iABC)assert(b:getBMode(d)~=b.OpArgMask.OpArgN or f==0)assert(b:getCMode(d)~=b.OpArgMask.OpArgN or h==0)return self:code(ak,b:CREATE_ABC(d,g,f,h),ak.ls.lastline)end;function aj:codeABx(ak,d,g,i)assert(b:getOpMode(d)==b.OpMode.iABx or b:getOpMode(d)==b.OpMode.iAsBx)assert(b:getCMode(d)==b.OpArgMask.OpArgN)return self:code(ak,b:CREATE_ABx(d,g,i),ak.ls.lastline)end;function aj:setlist(ak,bb,bc,bd)local h=math.floor((bc-1)/b.LFIELDS_PER_FLUSH)+1;local f=bd==luaY.LUA_MULTRET and 0 or bd;assert(bd~=0)if h<=b.MAXARG_C then self:codeABC(ak,"OP_SETLIST",bb,f,h)else self:codeABC(ak,"OP_SETLIST",bb,f,0)self:code(ak,b:CREATE_Inst(h),ak.ls.lastline)end;ak.freereg=bb+1 end;a.LuaK=function(g)luaY=g;return aj end;local luaY={}local T=a.LuaX;local aj=a.LuaK(luaY)local b=a.LuaP;luaY.LUA_QS=T.LUA_QS or"'%s'"luaY.SHRT_MAX=32767;luaY.LUAI_MAXVARS=200;luaY.LUAI_MAXUPVALUES=60;luaY.MAX_INT=T.MAX_INT or 2147483645;luaY.LUAI_MAXCCALLS=200;luaY.VARARG_HASARG=1;luaY.HASARG_MASK=2;luaY.VARARG_ISVARARG=2;luaY.VARARG_NEEDSARG=4;luaY.LUA_MULTRET=-1;function luaY:LUA_QL(o)return"'"..o.."'"end;function luaY:growvector(Q,s,bc,be,v,bf,al)if bc>=bf then error(al)end end;function luaY:newproto(Q)local N={}N.k={}N.sizek=0;N.p={}N.sizep=0;N.code={}N.sizecode=0;N.sizelineinfo=0;N.sizeupvalues=0;N.nups=0;N.upvalues={}N.numparams=0;N.is_vararg=0;N.maxstacksize=0;N.lineinfo={}N.sizelocvars=0;N.locvars={}N.lineDefined=0;N.lastlinedefined=0;N.source=nil;return N end;function luaY:int2fb(o)local al=0;while o>=16 do o=math.floor((o+1)/2)al=al+1 end;if o<8 then return o else return(al+1)*8+o-8 end end;function luaY:hasmultret(aM)return aM=="VCALL"or aM=="VVARARG"end;function luaY:getlocvar(ak,c)return ak.f.locvars[ak.actvar[c]]end;function luaY:checklimit(ak,s,a1,u)if s>a1 then self:errorlimit(ak,a1,u)end end;function luaY:anchor_token(a3)if a3.t.token=="TK_NAME"or a3.t.token=="TK_STRING"then end end;function luaY:error_expected(a3,a4)T:syntaxerror(a3,string.format(self.LUA_QS.." expected",T:token2str(a3,a4)))end;function luaY:errorlimit(ak,bf,bg)local a5=ak.f.linedefined==0 and string.format("main function has more than %d %s",bf,bg)or string.format("function at line %d has more than %d %s",ak.f.linedefined,bf,bg)T:lexerror(ak.ls,a5,0)end;function luaY:testnext(a3,h)if a3.t.token==h then T:next(a3)return true else return false end end;function luaY:check(a3,h)if a3.t.token~=h then self:error_expected(a3,h)end end;function luaY:checknext(a3,h)self:check(a3,h)T:next(a3)end;function luaY:check_condition(a3,h,a5)if not h then T:syntaxerror(a3,a5)end end;function luaY:check_match(a3,bg,bh,bi)if not self:testnext(a3,bg)then if bi==a3.linenumber then self:error_expected(a3,bg)else T:syntaxerror(a3,string.format(self.LUA_QS.." expected (to close "..self.LUA_QS.." at line %d)",T:token2str(a3,bg),T:token2str(a3,bh),bi))end end end;function luaY:str_checkname(a3)self:check(a3,"TK_NAME")local ai=a3.t.seminfo;T:next(a3)return ai end;function luaY:init_exp(al,aM,c)al.f,al.t=aj.NO_JUMP,aj.NO_JUMP;al.k=aM;al.info=c end;function luaY:codestring(a3,al,F)self:init_exp(al,"VK",aj:stringK(a3.fs,F))end;function luaY:checkname(a3,al)self:codestring(a3,al,self:str_checkname(a3))end;function luaY:registerlocalvar(a3,bj)local ak=a3.fs;local N=ak.f;self:growvector(a3.L,N.locvars,ak.nlocvars,N.sizelocvars,nil,self.SHRT_MAX,"too many local variables")N.locvars[ak.nlocvars]={}N.locvars[ak.nlocvars].varname=bj;local bk=ak.nlocvars;ak.nlocvars=ak.nlocvars+1;return bk end;function luaY:new_localvarliteral(a3,s,t)self:new_localvar(a3,s,t)end;function luaY:new_localvar(a3,A,t)local ak=a3.fs;self:checklimit(ak,ak.nactvar+t+1,self.LUAI_MAXVARS,"local variables")ak.actvar[ak.nactvar+t]=self:registerlocalvar(a3,A)end;function luaY:adjustlocalvars(a3,bl)local ak=a3.fs;ak.nactvar=ak.nactvar+bl;for c=bl,1,-1 do self:getlocvar(ak,ak.nactvar-c).startpc=ak.pc end end;function luaY:removevars(a3,bm)local ak=a3.fs;while ak.nactvar>bm do ak.nactvar=ak.nactvar-1;self:getlocvar(ak,ak.nactvar).endpc=ak.pc end end;function luaY:indexupvalue(ak,A,s)local N=ak.f;for c=0,N.nups-1 do if ak.upvalues[c].k==s.k and ak.upvalues[c].info==s.info then assert(N.upvalues[c]==A)return c end end;self:checklimit(ak,N.nups+1,self.LUAI_MAXUPVALUES,"upvalues")self:growvector(ak.L,N.upvalues,N.nups,N.sizeupvalues,nil,self.MAX_INT,"")N.upvalues[N.nups]=A;assert(s.k=="VLOCAL"or s.k=="VUPVAL")ak.upvalues[N.nups]={k=s.k,info=s.info}local bn=N.nups;N.nups=N.nups+1;return bn end;function luaY:searchvar(ak,t)for c=ak.nactvar-1,0,-1 do if t==self:getlocvar(ak,c).varname then return c end end;return-1 end;function luaY:markupval(ak,bo)local bp=ak.bl;while bp and bp.nactvar>bo do bp=bp.previous end;if bp then bp.upval=true end end;function luaY:singlevaraux(ak,t,aW,bb)if ak==nil then self:init_exp(aW,"VGLOBAL",b.NO_REG)return"VGLOBAL"else local s=self:searchvar(ak,t)if s>=0 then self:init_exp(aW,"VLOCAL",s)if bb==0 then self:markupval(ak,s)end;return"VLOCAL"else if self:singlevaraux(ak.prev,t,aW,0)=="VGLOBAL"then return"VGLOBAL"end;aW.info=self:indexupvalue(ak,t,aW)aW.k="VUPVAL"return"VUPVAL"end end end;function luaY:singlevar(a3,aW)local bj=self:str_checkname(a3)local ak=a3.fs;if self:singlevaraux(ak,bj,aW,1)=="VGLOBAL"then aW.info=aj:stringK(ak,bj)end end;function luaY:adjust_assign(a3,bl,bq,al)local ak=a3.fs;local br=bl-bq;if self:hasmultret(al.k)then br=br+1;if br<=0 then br=0 end;aj:setreturns(ak,al,br)if br>1 then aj:reserveregs(ak,br-1)end else if al.k~="VVOID"then aj:exp2nextreg(ak,al)end;if br>0 then local aE=ak.freereg;aj:reserveregs(ak,br)aj:_nil(ak,aE,br)end end end;function luaY:enterlevel(a3)a3.L.nCcalls=a3.L.nCcalls+1;if a3.L.nCcalls>self.LUAI_MAXCCALLS then T:lexerror(a3,"chunk has too many syntax levels",0)end end;function luaY:leavelevel(a3)a3.L.nCcalls=a3.L.nCcalls-1 end;function luaY:enterblock(ak,bp,bs)bp.breaklist=aj.NO_JUMP;bp.isbreakable=bs;bp.nactvar=ak.nactvar;bp.upval=false;bp.previous=ak.bl;ak.bl=bp;assert(ak.freereg==ak.nactvar)end;function luaY:leaveblock(ak)local bp=ak.bl;ak.bl=bp.previous;self:removevars(ak.ls,bp.nactvar)if bp.upval then aj:codeABC(ak,"OP_CLOSE",bp.nactvar,0,0)end;assert(not bp.isbreakable or not bp.upval)assert(bp.nactvar==ak.nactvar)ak.freereg=ak.nactvar;aj:patchtohere(ak,bp.breaklist)end;function luaY:pushclosure(a3,aZ,s)local ak=a3.fs;local N=ak.f;self:growvector(a3.L,N.p,ak.np,N.sizep,nil,b.MAXARG_Bx,"constant table overflow")N.p[ak.np]=aZ.f;ak.np=ak.np+1;self:init_exp(s,"VRELOCABLE",aj:codeABx(ak,"OP_CLOSURE",0,ak.np-1))for c=0,aZ.f.nups-1 do local d=aZ.upvalues[c].k=="VLOCAL"and"OP_MOVE"or"OP_GETUPVAL"aj:codeABC(ak,d,0,aZ.upvalues[c].info,0)end end;function luaY:open_func(a3,ak)local Q=a3.L;local N=self:newproto(a3.L)ak.f=N;ak.prev=a3.fs;ak.ls=a3;ak.L=Q;a3.fs=ak;ak.pc=0;ak.lasttarget=-1;ak.jpc=aj.NO_JUMP;ak.freereg=0;ak.nk=0;ak.np=0;ak.nlocvars=0;ak.nactvar=0;ak.bl=nil;N.source=a3.source;N.maxstacksize=2;ak.h={}end;function luaY:close_func(a3)local Q=a3.L;local ak=a3.fs;local N=ak.f;self:removevars(a3,0)aj:ret(ak,0,0)N.sizecode=ak.pc;N.sizelineinfo=ak.pc;N.sizek=ak.nk;N.sizep=ak.np;N.sizelocvars=ak.nlocvars;N.sizeupvalues=N.nups;assert(ak.bl==nil)a3.fs=ak.prev;if ak then self:anchor_token(a3)end end;function luaY:parser(Q,B,x,A)local bt={}bt.t={}bt.lookahead={}local bu={}bu.upvalues={}bu.actvar={}Q.nCcalls=0;bt.buff=x;T:setinput(Q,bt,B,A)self:open_func(bt,bu)bu.f.is_vararg=self.VARARG_ISVARARG;T:next(bt)self:chunk(bt)self:check(bt,"TK_EOS")self:close_func(bt)assert(bu.prev==nil)assert(bu.f.nups==0)assert(bt.fs==nil)return bu.f end;function luaY:field(a3,s)local ak=a3.fs;local aY={}aj:exp2anyreg(ak,s)T:next(a3)self:checkname(a3,aY)aj:indexed(ak,s,aY)end;function luaY:yindex(a3,s)T:next(a3)self:expr(a3,s)aj:exp2val(a3.fs,s)self:checknext(a3,"]")end;function luaY:recfield(a3,bv)local ak=a3.fs;local aE=a3.fs.freereg;local aY,bw={},{}if a3.t.token=="TK_NAME"then self:checklimit(ak,bv.nh,self.MAX_INT,"items in a constructor")self:checkname(a3,aY)else self:yindex(a3,aY)end;bv.nh=bv.nh+1;self:checknext(a3,"=")local bx=aj:exp2RK(ak,aY)self:expr(a3,bw)aj:codeABC(ak,"OP_SETTABLE",bv.t.info,bx,aj:exp2RK(ak,bw))ak.freereg=aE end;function luaY:closelistfield(ak,bv)if bv.v.k=="VVOID"then return end;aj:exp2nextreg(ak,bv.v)bv.v.k="VVOID"if bv.tostore==b.LFIELDS_PER_FLUSH then aj:setlist(ak,bv.t.info,bv.na,bv.tostore)bv.tostore=0 end end;function luaY:lastlistfield(ak,bv)if bv.tostore==0 then return end;if self:hasmultret(bv.v.k)then aj:setmultret(ak,bv.v)aj:setlist(ak,bv.t.info,bv.na,self.LUA_MULTRET)bv.na=bv.na-1 else if bv.v.k~="VVOID"then aj:exp2nextreg(ak,bv.v)end;aj:setlist(ak,bv.t.info,bv.na,bv.tostore)end end;function luaY:listfield(a3,bv)self:expr(a3,bv.v)self:checklimit(a3.fs,bv.na,self.MAX_INT,"items in a constructor")bv.na=bv.na+1;bv.tostore=bv.tostore+1 end;function luaY:constructor(a3,v)local ak=a3.fs;local ba=a3.linenumber;local aw=aj:codeABC(ak,"OP_NEWTABLE",0,0,0)local bv={}bv.v={}bv.na,bv.nh,bv.tostore=0,0,0;bv.t=v;self:init_exp(v,"VRELOCABLE",aw)self:init_exp(bv.v,"VVOID",0)aj:exp2nextreg(a3.fs,v)self:checknext(a3,"{")repeat assert(bv.v.k=="VVOID"or bv.tostore>0)if a3.t.token=="}"then break end;self:closelistfield(ak,bv)local h=a3.t.token;if h=="TK_NAME"then T:lookahead(a3)if a3.lookahead.token~="="then self:listfield(a3,bv)else self:recfield(a3,bv)end elseif h=="["then self:recfield(a3,bv)else self:listfield(a3,bv)end until not self:testnext(a3,",")and not self:testnext(a3,";")self:check_match(a3,"}","{",ba)self:lastlistfield(ak,bv)b:SETARG_B(ak.f.code[aw],self:int2fb(bv.na))b:SETARG_C(ak.f.code[aw],self:int2fb(bv.nh))end;function luaY:parlist(a3)local ak=a3.fs;local N=ak.f;local by=0;N.is_vararg=0;if a3.t.token~=")"then repeat local h=a3.t.token;if h=="TK_NAME"then self:new_localvar(a3,self:str_checkname(a3),by)by=by+1 elseif h=="TK_DOTS"then T:next(a3)self:new_localvarliteral(a3,"arg",by)by=by+1;N.is_vararg=self.VARARG_HASARG+self.VARARG_NEEDSARG;N.is_vararg=N.is_vararg+self.VARARG_ISVARARG else T:syntaxerror(a3,"<name> or "..self:LUA_QL("...").." expected")end until N.is_vararg~=0 or not self:testnext(a3,",")end;self:adjustlocalvars(a3,by)N.numparams=ak.nactvar-N.is_vararg%self.HASARG_MASK;aj:reserveregs(ak,ak.nactvar)end;function luaY:body(a3,al,bz,ba)local bA={}bA.upvalues={}bA.actvar={}self:open_func(a3,bA)bA.f.lineDefined=ba;self:checknext(a3,"(")if bz then self:new_localvarliteral(a3,"self",0)self:adjustlocalvars(a3,1)end;self:parlist(a3)self:checknext(a3,")")self:chunk(a3)bA.f.lastlinedefined=a3.linenumber;self:check_match(a3,"TK_END","TK_FUNCTION",ba)self:close_func(a3)self:pushclosure(a3,bA,al)end;function luaY:explist1(a3,s)local t=1;self:expr(a3,s)while self:testnext(a3,",")do aj:exp2nextreg(a3.fs,s)self:expr(a3,s)t=t+1 end;return t end;function luaY:funcargs(a3,N)local ak=a3.fs;local bB={}local by;local ba=a3.linenumber;local h=a3.t.token;if h=="("then if ba~=a3.lastline then T:syntaxerror(a3,"ambiguous syntax (function call x new statement)")end;T:next(a3)if a3.t.token==")"then bB.k="VVOID"else self:explist1(a3,bB)aj:setmultret(ak,bB)end;self:check_match(a3,")","(",ba)elseif h=="{"then self:constructor(a3,bB)elseif h=="TK_STRING"then self:codestring(a3,bB,a3.t.seminfo)T:next(a3)else T:syntaxerror(a3,"function arguments expected")return end;assert(N.k=="VNONRELOC")local bb=N.info;if self:hasmultret(bB.k)then by=self.LUA_MULTRET else if bB.k~="VVOID"then aj:exp2nextreg(ak,bB)end;by=ak.freereg-(bb+1)end;self:init_exp(N,"VCALL",aj:codeABC(ak,"OP_CALL",bb,by+1,2))aj:fixline(ak,ba)ak.freereg=bb+1 end;function luaY:prefixexp(a3,s)local h=a3.t.token;if h=="("then local ba=a3.linenumber;T:next(a3)self:expr(a3,s)self:check_match(a3,")","(",ba)aj:dischargevars(a3.fs,s)elseif h=="TK_NAME"then self:singlevar(a3,s)else T:syntaxerror(a3,"unexpected symbol")end;return end;function luaY:primaryexp(a3,s)local ak=a3.fs;self:prefixexp(a3,s)while true do local h=a3.t.token;if h=="."then self:field(a3,s)elseif h=="["then local aY={}aj:exp2anyreg(ak,s)self:yindex(a3,aY)aj:indexed(ak,s,aY)elseif h==":"then local aY={}T:next(a3)self:checkname(a3,aY)aj:_self(ak,s,aY)self:funcargs(a3,s)elseif h=="("or h=="TK_STRING"or h=="{"then aj:exp2nextreg(ak,s)self:funcargs(a3,s)else return end end end;function luaY:simpleexp(a3,s)local h=a3.t.token;if h=="TK_NUMBER"then self:init_exp(s,"VKNUM",0)s.nval=a3.t.seminfo elseif h=="TK_STRING"then self:codestring(a3,s,a3.t.seminfo)elseif h=="TK_NIL"then self:init_exp(s,"VNIL",0)elseif h=="TK_TRUE"then self:init_exp(s,"VTRUE",0)elseif h=="TK_FALSE"then self:init_exp(s,"VFALSE",0)elseif h=="TK_DOTS"then local ak=a3.fs;self:check_condition(a3,ak.f.is_vararg~=0,"cannot use "..self:LUA_QL("...").." outside a vararg function")local bC=ak.f.is_vararg;if bC>=self.VARARG_NEEDSARG then ak.f.is_vararg=bC-self.VARARG_NEEDSARG end;self:init_exp(s,"VVARARG",aj:codeABC(ak,"OP_VARARG",0,1,0))elseif h=="{"then self:constructor(a3,s)return elseif h=="TK_FUNCTION"then T:next(a3)self:body(a3,s,false,a3.linenumber)return else self:primaryexp(a3,s)return end;T:next(a3)end;function luaY:getunopr(q)if q=="TK_NOT"then return"OPR_NOT"elseif q=="-"then return"OPR_MINUS"elseif q=="#"then return"OPR_LEN"else return"OPR_NOUNOPR"end end;luaY.getbinopr_table={["+"]="OPR_ADD",["-"]="OPR_SUB",["*"]="OPR_MUL",["/"]="OPR_DIV",["%"]="OPR_MOD",["^"]="OPR_POW",["TK_CONCAT"]="OPR_CONCAT",["TK_NE"]="OPR_NE",["TK_EQ"]="OPR_EQ",["<"]="OPR_LT",["TK_LE"]="OPR_LE",[">"]="OPR_GT",["TK_GE"]="OPR_GE",["TK_AND"]="OPR_AND",["TK_OR"]="OPR_OR"}function luaY:getbinopr(q)local bD=self.getbinopr_table[q]if bD then return bD else return"OPR_NOBINOPR"end end;luaY.priority={{6,6},{6,6},{7,7},{7,7},{7,7},{10,9},{5,4},{3,3},{3,3},{3,3},{3,3},{3,3},{3,3},{2,2},{1,1}}luaY.UNARY_PRIORITY=8;function luaY:subexpr(a3,s,bf)self:enterlevel(a3)local bE=self:getunopr(a3.t.token)if bE~="OPR_NOUNOPR"then T:next(a3)self:subexpr(a3,s,self.UNARY_PRIORITY)aj:prefix(a3.fs,bE,s)else self:simpleexp(a3,s)end;local q=self:getbinopr(a3.t.token)while q~="OPR_NOBINOPR"and self.priority[aj.BinOpr[q]+1][1]>bf do local b4={}T:next(a3)aj:infix(a3.fs,q,s)local bF=self:subexpr(a3,b4,self.priority[aj.BinOpr[q]+1][2])aj:posfix(a3.fs,q,s,b4)q=bF end;self:leavelevel(a3)return q end;function luaY:expr(a3,s)self:subexpr(a3,s,0)end;function luaY:block_follow(a4)if a4=="TK_ELSE"or a4=="TK_ELSEIF"or a4=="TK_END"or a4=="TK_UNTIL"or a4=="TK_EOS"then return true else return false end end;function luaY:block(a3)local ak=a3.fs;local bp={}self:enterblock(ak,bp,false)self:chunk(a3)assert(bp.breaklist==aj.NO_JUMP)self:leaveblock(ak)end;function luaY:check_conflict(a3,bG,s)local ak=a3.fs;local br=ak.freereg;local bH=false;while bG do if bG.v.k=="VINDEXED"then if bG.v.info==s.info then bH=true;bG.v.info=br end;if bG.v.aux==s.info then bH=true;bG.v.aux=br end end;bG=bG.prev end;if bH then aj:codeABC(ak,"OP_MOVE",ak.freereg,s.info,0)aj:reserveregs(ak,1)end end;function luaY:assignment(a3,bG,bl)local al={}local h=bG.v.k;self:check_condition(a3,h=="VLOCAL"or h=="VUPVAL"or h=="VGLOBAL"or h=="VINDEXED","syntax error")if self:testnext(a3,",")then local bI={}bI.v={}bI.prev=bG;self:primaryexp(a3,bI.v)if bI.v.k=="VLOCAL"then self:check_conflict(a3,bG,bI.v)end;self:checklimit(a3.fs,bl,self.LUAI_MAXCCALLS-a3.L.nCcalls,"variables in assignment")self:assignment(a3,bI,bl+1)else self:checknext(a3,"=")local bq=self:explist1(a3,al)if bq~=bl then self:adjust_assign(a3,bl,bq,al)if bq>bl then a3.fs.freereg=a3.fs.freereg-(bq-bl)end else aj:setoneret(a3.fs,al)aj:storevar(a3.fs,bG.v,al)return end end;self:init_exp(al,"VNONRELOC",a3.fs.freereg-1)aj:storevar(a3.fs,bG.v,al)end;function luaY:cond(a3)local s={}self:expr(a3,s)if s.k=="VNIL"then s.k="VFALSE"end;aj:goiftrue(a3.fs,s)return s.f end;function luaY:breakstat(a3)local ak=a3.fs;local bp=ak.bl;local bJ=false;while bp and not bp.isbreakable do if bp.upval then bJ=true end;bp=bp.previous end;if not bp then T:syntaxerror(a3,"no loop to break")end;if bJ then aj:codeABC(ak,"OP_CLOSE",bp.nactvar,0,0)end;bp.breaklist=aj:concat(ak,bp.breaklist,aj:jump(ak))end;function luaY:whilestat(a3,ba)local ak=a3.fs;local bp={}T:next(a3)local bK=aj:getlabel(ak)local bL=self:cond(a3)self:enterblock(ak,bp,true)self:checknext(a3,"TK_DO")self:block(a3)aj:patchlist(ak,aj:jump(ak),bK)self:check_match(a3,"TK_END","TK_WHILE",ba)self:leaveblock(ak)aj:patchtohere(ak,bL)end;function luaY:repeatstat(a3,ba)local ak=a3.fs;local bM=aj:getlabel(ak)local bN,bO={},{}self:enterblock(ak,bN,true)self:enterblock(ak,bO,false)T:next(a3)self:chunk(a3)self:check_match(a3,"TK_UNTIL","TK_REPEAT",ba)local bL=self:cond(a3)if not bO.upval then self:leaveblock(ak)aj:patchlist(a3.fs,bL,bM)else self:breakstat(a3)aj:patchtohere(a3.fs,bL)self:leaveblock(ak)aj:patchlist(a3.fs,aj:jump(ak),bM)end;self:leaveblock(ak)end;function luaY:exp1(a3)local al={}self:expr(a3,al)local aM=al.k;aj:exp2nextreg(a3.fs,al)return aM end;function luaY:forbody(a3,bb,ba,bl,bP)local bp={}local ak=a3.fs;self:adjustlocalvars(a3,3)self:checknext(a3,"TK_DO")local bQ=bP and aj:codeAsBx(ak,"OP_FORPREP",bb,aj.NO_JUMP)or aj:jump(ak)self:enterblock(ak,bp,false)self:adjustlocalvars(a3,bl)aj:reserveregs(ak,bl)self:block(a3)self:leaveblock(ak)aj:patchtohere(ak,bQ)local bR=bP and aj:codeAsBx(ak,"OP_FORLOOP",bb,aj.NO_JUMP)or aj:codeABC(ak,"OP_TFORLOOP",bb,0,bl)aj:fixline(ak,ba)aj:patchlist(ak,bP and bR or aj:jump(ak),bQ+1)end;function luaY:fornum(a3,bj,ba)local ak=a3.fs;local bb=ak.freereg;self:new_localvarliteral(a3,"(for index)",0)self:new_localvarliteral(a3,"(for limit)",1)self:new_localvarliteral(a3,"(for step)",2)self:new_localvar(a3,bj,3)self:checknext(a3,'=')self:exp1(a3)self:checknext(a3,",")self:exp1(a3)if self:testnext(a3,",")then self:exp1(a3)else aj:codeABx(ak,"OP_LOADK",ak.freereg,aj:numberK(ak,1))aj:reserveregs(ak,1)end;self:forbody(a3,bb,ba,1,true)end;function luaY:forlist(a3,bS)local ak=a3.fs;local al={}local bl=0;local bb=ak.freereg;self:new_localvarliteral(a3,"(for generator)",bl)bl=bl+1;self:new_localvarliteral(a3,"(for state)",bl)bl=bl+1;self:new_localvarliteral(a3,"(for control)",bl)bl=bl+1;self:new_localvar(a3,bS,bl)bl=bl+1;while self:testnext(a3,",")do self:new_localvar(a3,self:str_checkname(a3),bl)bl=bl+1 end;self:checknext(a3,"TK_IN")local ba=a3.linenumber;self:adjust_assign(a3,3,self:explist1(a3,al),al)aj:checkstack(ak,3)self:forbody(a3,bb,ba,bl-3,false)end;function luaY:forstat(a3,ba)local ak=a3.fs;local bp={}self:enterblock(ak,bp,true)T:next(a3)local bj=self:str_checkname(a3)local h=a3.t.token;if h=="="then self:fornum(a3,bj,ba)elseif h==","or h=="TK_IN"then self:forlist(a3,bj)else T:syntaxerror(a3,self:LUA_QL("=").." or "..self:LUA_QL("in").." expected")end;self:check_match(a3,"TK_END","TK_FOR",ba)self:leaveblock(ak)end;function luaY:test_then_block(a3)T:next(a3)local bL=self:cond(a3)self:checknext(a3,"TK_THEN")self:block(a3)return bL end;function luaY:ifstat(a3,ba)local ak=a3.fs;local bT=aj.NO_JUMP;local bU=self:test_then_block(a3)while a3.t.token=="TK_ELSEIF"do bT=aj:concat(ak,bT,aj:jump(ak))aj:patchtohere(ak,bU)bU=self:test_then_block(a3)end;if a3.t.token=="TK_ELSE"then bT=aj:concat(ak,bT,aj:jump(ak))aj:patchtohere(ak,bU)T:next(a3)self:block(a3)else bT=aj:concat(ak,bT,bU)end;aj:patchtohere(ak,bT)self:check_match(a3,"TK_END","TK_IF",ba)end;function luaY:localfunc(a3)local s,f={},{}local ak=a3.fs;self:new_localvar(a3,self:str_checkname(a3),0)self:init_exp(s,"VLOCAL",ak.freereg)aj:reserveregs(ak,1)self:adjustlocalvars(a3,1)self:body(a3,f,false,a3.linenumber)aj:storevar(ak,s,f)self:getlocvar(ak,ak.nactvar-1).startpc=ak.pc end;function luaY:localstat(a3)local bl=0;local bq;local al={}repeat self:new_localvar(a3,self:str_checkname(a3),bl)bl=bl+1 until not self:testnext(a3,",")if self:testnext(a3,"=")then bq=self:explist1(a3,al)else al.k="VVOID"bq=0 end;self:adjust_assign(a3,bl,bq,al)self:adjustlocalvars(a3,bl)end;function luaY:funcname(a3,s)local bz=false;self:singlevar(a3,s)while a3.t.token=="."do self:field(a3,s)end;if a3.t.token==":"then bz=true;self:field(a3,s)end;return bz end;function luaY:funcstat(a3,ba)local s,f={},{}T:next(a3)local bz=self:funcname(a3,s)self:body(a3,f,bz,ba)aj:storevar(a3.fs,s,f)aj:fixline(a3.fs,ba)end;function luaY:exprstat(a3)local ak=a3.fs;local s={}s.v={}self:primaryexp(a3,s.v)if s.v.k=="VCALL"then b:SETARG_C(aj:getcode(ak,s.v),1)else s.prev=nil;self:assignment(a3,s,1)end end;function luaY:retstat(a3)local ak=a3.fs;local al={}local a0,at;T:next(a3)if self:block_follow(a3.t.token)or a3.t.token==";"then a0,at=0,0 else at=self:explist1(a3,al)if self:hasmultret(al.k)then aj:setmultret(ak,al)if al.k=="VCALL"and at==1 then b:SET_OPCODE(aj:getcode(ak,al),"OP_TAILCALL")assert(b:GETARG_A(aj:getcode(ak,al))==ak.nactvar)end;a0=ak.nactvar;at=self.LUA_MULTRET else if at==1 then a0=aj:exp2anyreg(ak,al)else aj:exp2nextreg(ak,al)a0=ak.nactvar;assert(at==ak.freereg-a0)end end end;aj:ret(ak,a0,at)end;function luaY:statement(a3)local ba=a3.linenumber;local h=a3.t.token;if h=="TK_IF"then self:ifstat(a3,ba)return false elseif h=="TK_WHILE"then self:whilestat(a3,ba)return false elseif h=="TK_DO"then T:next(a3)self:block(a3)self:check_match(a3,"TK_END","TK_DO",ba)return false elseif h=="TK_FOR"then self:forstat(a3,ba)return false elseif h=="TK_REPEAT"then self:repeatstat(a3,ba)return false elseif h=="TK_FUNCTION"then self:funcstat(a3,ba)return false elseif h=="TK_LOCAL"then T:next(a3)if self:testnext(a3,"TK_FUNCTION")then self:localfunc(a3)else self:localstat(a3)end;return false elseif h=="TK_RETURN"then self:retstat(a3)return true elseif h=="TK_BREAK"then T:next(a3)self:breakstat(a3)return true else self:exprstat(a3)return false end end;function luaY:chunk(a3)local bV=false;self:enterlevel(a3)while not bV and not self:block_follow(a3.t.token)do bV=self:statement(a3)self:testnext(a3,";")assert(a3.fs.f.maxstacksize>=a3.fs.freereg and a3.fs.freereg>=a3.fs.nactvar)a3.fs.freereg=a3.fs.nactvar end;self:leavelevel(a3)end;a.LuaY=luaY;local bW={_TYPE='module',_NAME='bitop.funcs',_VERSION='1.0-0'}local bX=math.floor;local bY=2^32;local bZ=bY-1;local function b_(N)local c0={}local v=setmetatable({},c0)function c0:__index(aM)local s=N(aM)v[aM]=s;return s end;return v end;local function c1(v,u)local function c2(g,f)local c3,C=0,1;while g~=0 and f~=0 do local c4,c5=g%u,f%u;c3=c3+v[c4][c5]*C;g=(g-c4)/u;f=(f-c5)/u;C=C*u end;c3=c3+(g+f)*C;return c3 end;return c2 end;local function c6(v)local c7=c1(v,2^1)local c8=b_(function(g)return b_(function(f)return c7(g,f)end)end)return c1(c8,2^(v.n or 1))end;function bW.tobit(o)return o%2^32 end;bW.bxor=c6{[0]={[0]=0,[1]=1},[1]={[0]=1,[1]=0},n=4}local c9=bW.bxor;function bW.bnot(g)return bZ-g end;local ca=bW.bnot;function bW.band(g,f)return(g+f-c9(g,f))/2 end;local cb=bW.band;function bW.bor(g,f)return bZ-cb(bZ-g,bZ-f)end;local cc=bW.bor;local cd,ce;function bW.rshift(g,cf)if cf<0 then return cd(g,-cf)end;return bX(g%2^32/2^cf)end;ce=bW.rshift;function bW.lshift(g,cf)if cf<0 then return ce(g,-cf)end;return g*2^cf%2^32 end;cd=bW.lshift;function bW.tohex(o,t)t=t or 8;local cg;if t<=0 then if t==0 then return''end;cg=true;t=-t end;o=cb(o,16^t-1)return('%0'..t..(cg and'X'or'x')):format(o)end;local ch=bW.tohex;function bW.extract(t,ci,cj)cj=cj or 1;return cb(ce(t,ci),2^cj-1)end;local ck=bW.extract;function bW.replace(t,s,ci,cj)cj=cj or 1;local cl=2^cj-1;s=cb(s,cl)local cm=ca(cd(cl,ci))return cb(t,cm)+cd(s,ci)end;local cn=bW.replace;function bW.bswap(o)local g=cb(o,0xff)o=ce(o,8)local f=cb(o,0xff)o=ce(o,8)local h=cb(o,0xff)o=ce(o,8)local co=cb(o,0xff)return cd(cd(cd(g,8)+f,8)+h,8)+co end;local cp=bW.bswap;function bW.rrotate(o,cf)cf=cf%32;local cq=cb(o,2^cf-1)return ce(o,cf)+cd(cq,32-cf)end;local cr=bW.rrotate;function bW.lrotate(o,cf)return cr(o,-cf)end;local cs=bW.lrotate;bW.rol=bW.lrotate;bW.ror=bW.rrotate;function bW.arshift(o,cf)local B=ce(o,cf)if o>=0x80000000 then B=B+cd(2^cf-1,32-cf)end;return B end;local ct=bW.arshift;function bW.btest(o,M)return cb(o,M)~=0 end;bW.bit32={}local function cu(o)return(-1-o)%bY end;bW.bit32.bnot=cu;local function cv(g,f,h,...)local B;if f then g=g%bY;f=f%bY;B=c9(g,f)if h then B=cv(B,h,...)end;return B elseif g then return g%bY else return 0 end end;bW.bit32.bxor=cv;local function cw(g,f,h,...)local B;if f then g=g%bY;f=f%bY;B=(g+f-c9(g,f))/2;if h then B=cw(B,h,...)end;return B elseif g then return g%bY else return bZ end end;bW.bit32.band=cw;local function cx(g,f,h,...)local B;if f then g=g%bY;f=f%bY;B=bZ-cb(bZ-g,bZ-f)if h then B=cx(B,h,...)end;return B elseif g then return g%bY else return 0 end end;bW.bit32.bor=cx;function bW.bit32.btest(...)return cw(...)~=0 end;function bW.bit32.lrotate(o,cf)return cs(o%bY,cf)end;function bW.bit32.rrotate(o,cf)return cr(o%bY,cf)end;function bW.bit32.lshift(o,cf)if cf>31 or cf<-31 then return 0 end;return cd(o%bY,cf)end;function bW.bit32.rshift(o,cf)if cf>31 or cf<-31 then return 0 end;return ce(o%bY,cf)end;function bW.bit32.arshift(o,cf)o=o%bY;if cf>=0 then if cf>31 then return o>=0x80000000 and bZ or 0 else local B=ce(o,cf)if o>=0x80000000 then B=B+cd(2^cf-1,32-cf)end;return B end else return cd(o,-cf)end end;function bW.bit32.extract(o,ci,...)local cj=...or 1;if ci<0 or ci>31 or cj<0 or ci+cj>32 then error'out of range'end;o=o%bY;return ck(o,ci,...)end;function bW.bit32.replace(o,s,ci,...)local cj=...or 1;if ci<0 or ci>31 or cj<0 or ci+cj>32 then error'out of range'end;o=o%bY;s=s%bY;return cn(o,s,ci,...)end;bW.bit={}function bW.bit.tobit(o)o=o%bY;if o>=0x80000000 then o=o-bY end;return o end;local cy=bW.bit.tobit;function bW.bit.tohex(o,...)return ch(o%bY,...)end;function bW.bit.bnot(o)return cy(ca(o%bY))end;local function cz(g,f,h,...)if h then return cz(cz(g,f),h,...)elseif f then return cy(cc(g%bY,f%bY))else return cy(g)end end;bW.bit.bor=cz;local function cA(g,f,h,...)if h then return cA(cA(g,f),h,...)elseif f then return cy(cb(g%bY,f%bY))else return cy(g)end end;bW.bit.band=cA;local function cB(g,f,h,...)if h then return cB(cB(g,f),h,...)elseif f then return cy(c9(g%bY,f%bY))else return cy(g)end end;bW.bit.bxor=cB;function bW.bit.lshift(o,t)return cy(cd(o%bY,t%32))end;function bW.bit.rshift(o,t)return cy(ce(o%bY,t%32))end;function bW.bit.arshift(o,t)return cy(ct(o%bY,t%32))end;function bW.bit.rol(o,t)return cy(cs(o%bY,t%32))end;function bW.bit.ror(o,t)return cy(cr(o%bY,t%32))end;function bW.bit.bswap(o)return cy(cp(o%bY))end;bit=bW.bit;local bit=bit or bit32 or require('bit')local unpack=table.unpack or unpack;local cC;local cD;local cE;local cF=50;local cG={[0]='ABC','ABx','ABC','ABC','ABC','ABx','ABC','ABx','ABC','ABC','ABC','ABC','ABC','ABC','ABC','ABC','ABC','ABC','ABC','ABC','ABC','ABC','AsBx','ABC','ABC','ABC','ABC','ABC','ABC','ABC','ABC','AsBx','AsBx','ABC','ABC','ABC','ABx','ABC'}local cH={[0]={b='OpArgR',c='OpArgN'},{b='OpArgK',c='OpArgN'},{b='OpArgU',c='OpArgU'},{b='OpArgR',c='OpArgN'},{b='OpArgU',c='OpArgN'},{b='OpArgK',c='OpArgN'},{b='OpArgR',c='OpArgK'},{b='OpArgK',c='OpArgN'},{b='OpArgU',c='OpArgN'},{b='OpArgK',c='OpArgK'},{b='OpArgU',c='OpArgU'},{b='OpArgR',c='OpArgK'},{b='OpArgK',c='OpArgK'},{b='OpArgK',c='OpArgK'},{b='OpArgK',c='OpArgK'},{b='OpArgK',c='OpArgK'},{b='OpArgK',c='OpArgK'},{b='OpArgK',c='OpArgK'},{b='OpArgR',c='OpArgN'},{b='OpArgR',c='OpArgN'},{b='OpArgR',c='OpArgN'},{b='OpArgR',c='OpArgR'},{b='OpArgR',c='OpArgN'},{b='OpArgK',c='OpArgK'},{b='OpArgK',c='OpArgK'},{b='OpArgK',c='OpArgK'},{b='OpArgR',c='OpArgU'},{b='OpArgR',c='OpArgU'},{b='OpArgU',c='OpArgU'},{b='OpArgU',c='OpArgU'},{b='OpArgU',c='OpArgN'},{b='OpArgR',c='OpArgN'},{b='OpArgR',c='OpArgN'},{b='OpArgN',c='OpArgU'},{b='OpArgU',c='OpArgU'},{b='OpArgN',c='OpArgN'},{b='OpArgU',c='OpArgN'},{b='OpArgU',c='OpArgN'}}local function cI(cJ,F,al,co)local cK=0;for c=F,al,co do cK=cK+cJ:byte(c,c)*256^(c-F)end;return cK end;local function cL(cM,cN,cO,cP)local I=(-1)^bit.rshift(cP,7)local cQ=bit.rshift(cO,7)+bit.lshift(bit.band(cP,0x7F),1)local cR=cM+bit.lshift(cN,8)+bit.lshift(bit.band(cO,0x7F),16)local cS=1;if cQ==0 then if cR==0 then return I*0 else cS=0;cQ=1 end elseif cQ==0x7F then if cR==0 then return I*1/0 else return I*0/0 end end;return I*2^(cQ-127)*(1+cS/2^23)end;local function cT(cM,cN,cO,cP,cU,cV,cW,cX)local I=(-1)^bit.rshift(cX,7)local cQ=bit.lshift(bit.band(cX,0x7F),4)+bit.rshift(cW,4)local cR=bit.band(cW,0x0F)*2^48;local cS=1;cR=cR+cV*2^40+cU*2^32+cP*2^24+cO*2^16+cN*2^8+cM;if cQ==0 then if cR==0 then return I*0 else cS=0;cQ=1 end elseif cQ==0x7FF then if cR==0 then return I*1/0 else return I*0/0 end end;return I*2^(cQ-1023)*(cS+cR/2^52)end;local function cY(cJ,F,al)return cI(cJ,F,al-1,1)end;local function cZ(cJ,F,al)return cI(cJ,al-1,F,-1)end;local function c_(cJ,F)return cL(cJ:byte(F,F+3))end;local function d0(cJ,F)local cM,cN,cO,cP=cJ:byte(F,F+3)return cL(cP,cO,cN,cM)end;local function d1(cJ,F)return cT(cJ:byte(F,F+7))end;local function d2(cJ,F)local cM,cN,cO,cP,cU,cV,cW,cX=cJ:byte(F,F+7)return cT(cX,cW,cV,cU,cP,cO,cN,cM)end;local d3={[4]={little=c_,big=d0},[8]={little=d1,big=d2}}local function d4(d5)local aN=d5.index;local d6=d5.source:byte(aN,aN)d5.index=aN+1;return d6 end;local function d7(d5,a2)local d8=d5.index+a2;local Y=d5.source:sub(d5.index,d8-1)d5.index=d8;return Y end;local function d9(d5)local a2=d5:s_szt()local Y;if a2~=0 then Y=d7(d5,a2):sub(1,-2)end;return Y end;local function da(a2,aZ)return function(d5)local d8=d5.index+a2;local db=aZ(d5.source,d5.index,d8)d5.index=d8;return db end end;local function dc(a2,aZ)return function(d5)local dd=aZ(d5.source,d5.index)d5.index=d5.index+a2;return dd end end;local function de(d5)local be=d5:s_int()local df={}for c=1,be do local dg=d5:s_ins()local q=bit.band(dg,0x3F)local bB=cG[q]local dh=cH[q]local y={value=dg,op=q,A=bit.band(bit.rshift(dg,6),0xFF)}if bB=='ABC'then y.B=bit.band(bit.rshift(dg,23),0x1FF)y.C=bit.band(bit.rshift(dg,14),0x1FF)y.is_KB=dh.b=='OpArgK'and y.B>0xFF;y.is_KC=dh.c=='OpArgK'and y.C>0xFF elseif bB=='ABx'then y.Bx=bit.band(bit.rshift(dg,14),0x3FFFF)y.is_K=dh.b=='OpArgK'elseif bB=='AsBx'then y.sBx=bit.band(bit.rshift(dg,14),0x3FFFF)-131071 end;df[c]=y end;return df end;local function di(d5)local be=d5:s_int()local dj={}for c=1,be do local G=d4(d5)local aM;if G==1 then aM=d4(d5)~=0 elseif G==3 then aM=d5:s_num()elseif G==4 then aM=d9(d5)end;dj[c]=aM end;return dj end;local function dk(d5,cJ)local be=d5:s_int()local dl={}for c=1,be do dl[c]=cE(d5,cJ)end;return dl end;local function dm(d5)local be=d5:s_int()local dn={}for c=1,be do dn[c]=d5:s_int()end;return dn end;local function dp(d5)local be=d5:s_int()local dq={}for c=1,be do dq[c]={varname=d9(d5),startpc=d5:s_int(),endpc=d5:s_int()}end;return dq end;local function dr(d5)local be=d5:s_int()local ds={}for c=1,be do ds[c]=d9(d5)end;return ds end;function cE(d5,dt)local du={}local cJ=d9(d5)or dt;du.source=cJ;d5:s_int()d5:s_int()du.numupvals=d4(d5)du.numparams=d4(d5)d4(d5)d4(d5)du.code=de(d5)du.const=di(d5)du.subs=dk(d5,cJ)du.lines=dm(d5)dp(d5)dr(d5)for W,s in ipairs(du.code)do if s.is_K then s.const=du.const[s.Bx+1]else if s.is_KB then s.const_B=du.const[s.B-0xFF]end;if s.is_KC then s.const_C=du.const[s.C-0xFF]end end end;return du end;function cC(cJ)local dv;local dw;local dx;local dy;local dz;local dA;local dB;local dC={index=1,source=cJ}assert(d7(dC,4)=='\27Lua','invalid Lua signature')assert(d4(dC)==0x51,'invalid Lua version')assert(d4(dC)==0,'invalid Lua format')dw=d4(dC)~=0;dx=d4(dC)dy=d4(dC)dz=d4(dC)dA=d4(dC)dB=d4(dC)~=0;dv=dw and cY or cZ;dC.s_int=da(dx,dv)dC.s_szt=da(dy,dv)dC.s_ins=da(dz,dv)if dB then dC.s_num=da(dA,dv)elseif d3[dA]then dC.s_num=dc(dA,d3[dA][dw and'little'or'big'])else error('unsupported float size')end;return cE(dC,'@virtual')end;local function dD(aC,dE)for c,dF in pairs(aC)do if dF.index>=dE then dF.value=dF.store[dF.index]dF.store=dF;dF.index='value'aC[c]=nil end end end;local function dG(aC,dE,dH)local dI=aC[dE]if not dI then dI={index=dE,store=dH}aC[dE]=dI end;return dI end;local function dJ(...)return select('#',...),{...}end;local function dK(dL,dM)local cJ=dL.source;local ba=dL.lines[dL.pc-1]local dt,dN,dO=dM:match('^(.-):(%d+):%s+(.+)')local dP='%s:%i: [%s:%i] %s'ba=ba or'0'dt=dt or'?'dN=dN or'0'dO=dO or dM;error(string.format(dP,cJ,ba,dt,dN,dO),0)end;local function dQ(dL)local df=dL.code;local dR=dL.subs;local dS=dL.env;local dT=dL.upvals;local dU=dL.varargs;local dV=-1;local dW={}local dH=dL.stack;local aw=dL.pc;while true do local dX=df[aw]local q=dX.op;aw=aw+1;if q<19 then if q<9 then if q<4 then if q<2 then if q<1 then dH[dX.A]=dH[dX.B]else dH[dX.A]=dX.const end elseif q>2 then for c=dX.A,dX.B do dH[c]=nil end else dH[dX.A]=dX.B~=0;if dX.C~=0 then aw=aw+1 end end elseif q>4 then if q<7 then if q<6 then dH[dX.A]=dS[dX.const]else local dE;if dX.is_KC then dE=dX.const_C else dE=dH[dX.C]end;dH[dX.A]=dH[dX.B][dE]end elseif q>7 then local dF=dT[dX.B]dF.store[dF.index]=dH[dX.A]else dS[dX.const]=dH[dX.A]end else local dF=dT[dX.B]dH[dX.A]=dF.store[dF.index]end elseif q>9 then if q<14 then if q<12 then if q<11 then dH[dX.A]={}else local am=dX.A;local au=dX.B;local dE;if dX.is_KC then dE=dX.const_C else dE=dH[dX.C]end;dH[am+1]=dH[au]dH[am]=dH[au][dE]end elseif q>12 then local dY,dZ;if dX.is_KB then dY=dX.const_B else dY=dH[dX.B]end;if dX.is_KC then dZ=dX.const_C else dZ=dH[dX.C]end;dH[dX.A]=dY-dZ else local dY,dZ;if dX.is_KB then dY=dX.const_B else dY=dH[dX.B]end;if dX.is_KC then dZ=dX.const_C else dZ=dH[dX.C]end;dH[dX.A]=dY+dZ end elseif q>14 then if q<17 then if q<16 then local dY,dZ;if dX.is_KB then dY=dX.const_B else dY=dH[dX.B]end;if dX.is_KC then dZ=dX.const_C else dZ=dH[dX.C]end;dH[dX.A]=dY/dZ else local dY,dZ;if dX.is_KB then dY=dX.const_B else dY=dH[dX.B]end;if dX.is_KC then dZ=dX.const_C else dZ=dH[dX.C]end;dH[dX.A]=dY%dZ end elseif q>17 then dH[dX.A]=-dH[dX.B]else local dY,dZ;if dX.is_KB then dY=dX.const_B else dY=dH[dX.B]end;if dX.is_KC then dZ=dX.const_C else dZ=dH[dX.C]end;dH[dX.A]=dY^dZ end else local dY,dZ;if dX.is_KB then dY=dX.const_B else dY=dH[dX.B]end;if dX.is_KC then dZ=dX.const_C else dZ=dH[dX.C]end;dH[dX.A]=dY*dZ end else local dE,d_;if dX.is_KB then dE=dX.const_B else dE=dH[dX.B]end;if dX.is_KC then d_=dX.const_C else d_=dH[dX.C]end;dH[dX.A][dE]=d_ end elseif q>19 then if q<29 then if q<24 then if q<22 then if q<21 then dH[dX.A]=#dH[dX.B]else local Y=dH[dX.B]for c=dX.B+1,dX.C do Y=Y..dH[c]end;dH[dX.A]=Y end elseif q>22 then local dY,dZ;if dX.is_KB then dY=dX.const_B else dY=dH[dX.B]end;if dX.is_KC then dZ=dX.const_C else dZ=dH[dX.C]end;if dY==dZ~=(dX.A~=0)then aw=aw+1 end else aw=aw+dX.sBx end elseif q>24 then if q<27 then if q<26 then local dY,dZ;if dX.is_KB then dY=dX.const_B else dY=dH[dX.B]end;if dX.is_KC then dZ=dX.const_C else dZ=dH[dX.C]end;if dY<=dZ~=(dX.A~=0)then aw=aw+1 end else if not dH[dX.A]==(dX.C~=0)then aw=aw+1 end end elseif q>27 then local am=dX.A;local au=dX.B;local av=dX.C;local e0;local e1,e2;if au==0 then e0=dV-am else e0=au-1 end;e1,e2=dJ(dH[am](unpack(dH,am+1,am+e0)))if av==0 then dV=am+e1-1 else e1=av-1 end;for c=1,e1 do dH[am+c-1]=e2[c]end else local am=dX.A;local au=dX.B;if not dH[au]==(dX.C~=0)then aw=aw+1 else dH[am]=dH[au]end end else local dY,dZ;if dX.is_KB then dY=dX.const_B else dY=dH[dX.B]end;if dX.is_KC then dZ=dX.const_C else dZ=dH[dX.C]end;if dY<dZ~=(dX.A~=0)then aw=aw+1 end end elseif q>29 then if q<34 then if q<32 then if q<31 then local am=dX.A;local au=dX.B;local e3={}local be;if au==0 then be=dV-am+1 else be=au-1 end;for c=1,be do e3[c]=dH[am+c-1]end;dD(dW,0)return be,e3 else local am=dX.A;local e4=dH[am+2]local dE=dH[am]+e4;local bf=dH[am+1]local e5;if e4==math.abs(e4)then e5=dE<=bf else e5=dE>=bf end;if e5 then dH[dX.A]=dE;dH[dX.A+3]=dE;aw=aw+dX.sBx end end elseif q>32 then local am=dX.A;local aZ=dH[am]local e6=dH[am+1]local dE=dH[am+2]local bb=am+3;local e3;dH[bb+2]=dE;dH[bb+1]=e6;dH[bb]=aZ;e3={aZ(e6,dE)}for c=1,dX.C do dH[bb+c-1]=e3[c]end;if dH[bb]~=nil then dH[am+2]=dH[bb]else aw=aw+1 end else local am=dX.A;local e7,bf,e4;e7=assert(tonumber(dH[am]),'`for` initial value must be a number')bf=assert(tonumber(dH[am+1]),'`for` limit must be a number')e4=assert(tonumber(dH[am+2]),'`for` step must be a number')dH[am]=e7-e4;dH[am+1]=bf;dH[am+2]=e4;aw=aw+dX.sBx end elseif q>34 then if q<36 then dD(dW,dX.A)elseif q>36 then local am=dX.A;local be=dX.B;if be==0 then be=dU.size;dV=am+be-1 end;for c=1,be do dH[am+c-1]=dU.list[c]end else local dl=dR[dX.Bx+1]local bn=dl.numupvals;local e8;if bn~=0 then e8={}for c=1,bn do local e9=df[aw+c-1]if e9.op==0 then e8[c-1]=dG(dW,e9.B,dH)elseif e9.op==4 then e8[c-1]=dT[e9.B]end end;aw=aw+bn end;dH[dX.A]=cD(dl,dS,e8)end else local am=dX.A;local av=dX.C;local be=dX.B;local ea=dH[am]local az;if be==0 then be=dV-am end;if av==0 then av=dX[aw].value;aw=aw+1 end;az=(av-1)*cF;for c=1,be do ea[c+az]=dH[am+c]end end else local am=dX.A;local au=dX.B;local e0;if au==0 then e0=dV-am else e0=au-1 end;dD(dW,0)return dJ(dH[am](unpack(dH,am+1,am+e0)))end else dH[dX.A]=not dH[dX.B]end;dL.pc=aw end end;function cD(e6,dS,ds)local eb=e6.code;local ec=e6.subs;local ed=e6.lines;local ee=e6.source;local ef=e6.numparams;local function eg(...)local dH={}local eh={}local ei=0;local ej,ek=dJ(...)local dL;local el,dM,e3;for c=1,ef do dH[c-1]=ek[c]end;if ef<ej then ei=ej-ef;for c=1,ei do eh[c]=ek[ef+c]end end;dL={varargs={list=eh,size=ei},code=eb,subs=ec,lines=ed,source=ee,env=dS,upvals=ds,stack=dH,pc=1}el,dM,e3=pcall(dQ,dL,...)if el then return unpack(e3,1,dM)else dK(dL,dM)end;return end;return eg end;a.Parser=cC;a.ParserWrap=cD;local T=a.LuaX;local luaY=a.LuaY;local w=a.LuaZ;local D=a.LuaU;local em=a.Parser;local en=a.ParserWrap;T:init()local eo={}a.Loadstring=function(Y,dS)local N,E,x;local ep,error=pcall(function()dS=dS or getfenv()local eq=w:init(w:make_getS(Y),nil)if not eq then return error()end;local aZ=luaY:parser(eo,eq,nil,"@input")E,x=D:make_setS()D:dump(eo,aZ,E,x)N=a.ParserWrap(em(x.data),dS)end)if ep then return N,x.data else return nil,error end end;a.Loadstring('print("test")')()